<html><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><title>CIlib</title><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="Verifiable Computational Intelligence" /><meta name="author" content="net.cilib" /><meta name="og:image" content="/cilib/img/poster.png" /><meta name="og:title" content="CIlib" /><meta name="og:site_name" content="CIlib" /><meta name="og:url" content="http://cirg-up.github.io" /><meta name="og:type" content="website" /><meta name="og:description" content="Verifiable Computational Intelligence" /><meta name="twitter:image" content="/cilib/img/poster.png" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:site" content="" /><link rel="icon" type="image/png" href="/cilib/img/favicon.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/cilib/highlight/styles/default.css" /><link rel="stylesheet" href="/cilib/css/style.css" /><link rel="stylesheet" href="/cilib/css/palette.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/cilib/" class="brand"><div class="brand-wrapper" style="background:url('/cilib/img/sidebar_brand.png') no-repeat"><span>CIlib</span></div></a></li> <li><a href="/cilib/docs/index.html" class="">Getting Started</a></li> <li><a href="/cilib/docs/design/index.html" class="">Design</a> <ul class="sub_section"> <li><a href="/cilib/docs/design/rvar.html" class="">RVar</a></li> <li><a href="/cilib/docs/design/position.html" class="">Position</a></li> <li><a href="/cilib/docs/design/lenses.html" class="">Lenses</a></li> <li><a href="/cilib/docs/design/entity.html" class=" active ">Entity</a></li> <li><a href="/cilib/docs/design/step.html" class="">Step & Iteration</a></li></ul></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li class="hidden-xs"><a href="https://github.com/cirg-up/cilib"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li class="hidden-xs"><a href="https://github.com/cirg-up/cilib"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('CIlib Verifiable Computational Intelligence');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('CIlib Verifiable Computational Intelligence');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="cirg-up" data-github-repo="cilib"><div class="content-wrapper"><section><h1 id="entity">Entity</h1>

<p>Within swarm intelligence, evolutionary computation and other, similar
algorithms, there is always a metaphor that the algorithm is based on.
Using this metaphor, the participants within the algorithm are also
appropriately named. For example, within a Particle Swarm Optimization (PSO),
the participants are referred to as Particles, with Individuals being
used in both Differential Evolution (DE) and Genetic Algorithms (GA).
Many other examples can easily be identified in available literature.</p>

<p>It is not practical to have several representations for a very similar
concept used within these algorithms. Based on experimentation within CIlib,
a common structure was identified that could be used to represent the
participants for these metaphor-based population based algorithms. We
refer, collectively, to these algorithm participants as <code class="highlighter-rouge">Entity</code> instances.</p>

<p>An <code class="highlighter-rouge">Entity</code> is a simple structure that contains and manages two very
specific things:</p>

<ul>
  <li>A <code class="highlighter-rouge">Position[A]</code> within the current search space of the problem</li>
  <li>A “state” that contains all addition data required by the <code class="highlighter-rouge">Entity</code>
which is not managed by the <code class="highlighter-rouge">Position[A]</code>.</li>
</ul>

<p>The resulting <code class="highlighter-rouge">Entity</code> is therefore represented by the following
parameterized data type:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>final case class Entity[S,A](state: S, pos: Position[A])
</code></pre>
</div>

<p>where <code class="highlighter-rouge">S</code> is the type of the state that the <code class="highlighter-rouge">Entity</code> maintains,
and <code class="highlighter-rouge">A</code> is the type of the dimension element within a <code class="highlighter-rouge">Position[A]</code>.</p>

<p>The state value differs between <code class="highlighter-rouge">Entity</code> instances. A Particle requires
a velocity vector and a previous best position vector, whilst an Individual,
requires no additional data other that a <code class="highlighter-rouge">Position</code>.</p>

<p>Because the value of <code class="highlighter-rouge">S</code> within the <code class="highlighter-rouge">Entity</code> can be anything, it is
not possible to have predefined functions that allow extraction of data
the <code class="highlighter-rouge">S</code> parameter type. In order to enable this, optics are applied to
the instances.</p>

<p>Within the definitions of CIlib, an Individual is nothing more than an
<code class="highlighter-rouge">Entity[Unit,A]</code> for some type <code class="highlighter-rouge">A</code>. As the type states, there is no
state value for the <code class="highlighter-rouge">Entity</code>, and it is defined to be <code class="highlighter-rouge">Unit</code> - a type that
exists with a single value (expressed as <code class="highlighter-rouge">()</code>), which is uninteresting.</p>

<p>Some functions use <code class="highlighter-rouge">Entity</code> instances, but
constrain the usage base don the shape of the <code class="highlighter-rouge">S</code> type parameter within the
<code class="highlighter-rouge">Entity[S,A]</code>. As mentioned within the discussion of
<a href="">lenses and optics</a>, a typeclass <code class="highlighter-rouge">HasMemory</code> is defined to allow a state
to contain information about some kind of memory for an <code class="highlighter-rouge">Entity</code>. A data
structure that provides this memory for a Particle is <code class="highlighter-rouge">Mem[A]</code>, and is simply
the case class:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>case class Mem[A](b: Position[A], v: Position[A])
</code></pre>
</div>

<p>There already exists an instance of <code class="highlighter-rouge">HasMemory</code> defined for the <code class="highlighter-rouge">Mem</code>
data structure. Let’s have a look at some usage:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="c1">// Lets create a function that expects the provided Entity to have
</span>     <span class="o">|</span> <span class="c1">// a memory within it's state parameter
</span>     <span class="o">|</span> <span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Entity</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Double</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">mem</span><span class="k">:</span> <span class="kt">HasMemory</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Double</span><span class="o">])</span> <span class="k">=</span>
     <span class="o">|</span>   <span class="n">mem</span><span class="o">.</span><span class="nc">_memory</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">state</span><span class="o">)</span>
<span class="n">foo</span><span class="k">:</span> <span class="err">[</span><span class="kt">S</span><span class="err">]</span><span class="o">(</span><span class="kt">x:</span> <span class="kt">cilib.Entity</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Double</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">mem</span><span class="k">:</span> <span class="kt">cilib.HasMemory</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Double</span><span class="o">])</span><span class="n">cilib</span><span class="o">.</span><span class="nc">Position</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="c1">// Now, lets create some Entity instances
</span>     <span class="o">|</span> <span class="k">val</span> <span class="n">interval</span> <span class="k">=</span> <span class="nc">Interval</span><span class="o">(-</span><span class="mf">5.12</span><span class="o">,</span><span class="mf">5.12</span><span class="o">)^</span><span class="mi">3</span>
<span class="n">interval</span><span class="k">:</span> <span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">spire.math.Interval</span><span class="o">[</span><span class="kt">Double</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">[[</span><span class="kt">-</span><span class="err">5</span><span class="kt">.</span><span class="err">12</span>, <span class="err">5</span><span class="kt">.</span><span class="err">12</span><span class="o">]</span>,<span class="o">[</span><span class="kt">-</span><span class="err">5</span><span class="kt">.</span><span class="err">12</span>, <span class="err">5</span><span class="kt">.</span><span class="err">12</span><span class="o">]</span>,<span class="o">[</span><span class="kt">-</span><span class="err">5</span><span class="kt">.</span><span class="err">12</span>, <span class="err">5</span><span class="kt">.</span><span class="err">12</span><span class="o">]]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">individual</span> <span class="k">=</span> <span class="nc">Position</span><span class="o">.</span><span class="n">createPosition</span><span class="o">(</span><span class="n">interval</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="nc">Entity</span><span class="o">((),</span> <span class="n">p</span><span class="o">))</span>
<span class="n">individual</span><span class="k">:</span> <span class="kt">cilib.RVar</span><span class="o">[</span><span class="kt">cilib.Entity</span><span class="o">[</span><span class="kt">Unit</span>,<span class="kt">Double</span><span class="o">]]</span> <span class="k">=</span> <span class="n">cilib</span><span class="o">.</span><span class="nc">RVar$$anon$2</span><span class="k">@</span><span class="mf">6429745f</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">particle</span> <span class="k">=</span> <span class="nc">Position</span><span class="o">.</span><span class="n">createPosition</span><span class="o">(</span><span class="n">interval</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="nc">Entity</span><span class="o">(</span><span class="nc">Mem</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="n">zeroed</span><span class="o">),</span> <span class="n">p</span><span class="o">))</span>
<span class="n">particle</span><span class="k">:</span> <span class="kt">cilib.RVar</span><span class="o">[</span><span class="kt">cilib.Entity</span><span class="o">[</span><span class="kt">cilib.Mem</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span>,<span class="kt">Double</span><span class="o">]]</span> <span class="k">=</span> <span class="n">cilib</span><span class="o">.</span><span class="nc">RVar$$anon$2</span><span class="k">@</span><span class="mi">6</span><span class="n">a3596f5</span>
</code></pre>
</div>

<p>Take note of the value held by the state parameter
in the resulting entity instances above.
We would need to run the <code class="highlighter-rouge">RVar</code> computation to get the individual and particle
values, or we can simply <code class="highlighter-rouge">map</code> the function <code class="highlighter-rouge">foo</code> into the <code class="highlighter-rouge">RVar</code>, changing
the result of the computation to a <code class="highlighter-rouge">RVar</code> which when executed will return the memory
of the <code class="highlighter-rouge">Entity</code>.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">particle</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="n">foo</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="c1">// This works as expected: particles have a memory
</span><span class="n">res3</span><span class="k">:</span> <span class="kt">cilib.RVar</span><span class="o">[</span><span class="kt">cilib.Position</span><span class="o">[</span><span class="kt">Double</span><span class="o">]]</span> <span class="k">=</span> <span class="n">cilib</span><span class="o">.</span><span class="nc">RVar$$anon$2</span><span class="nd">@e60aeaa</span>
</code></pre>
</div>

<p>Because <code class="highlighter-rouge">individual</code> does not have a memory defined, the following will fail.
This failure is not only expected but required to ensure that incorrect usages
are disallowed as soon as possible.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">individual</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">foo</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">24</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span> <span class="kt">mem:</span> <span class="kt">cilib.HasMemory</span><span class="o">[</span><span class="kt">Unit</span>,<span class="kt">Double</span><span class="o">]</span>
       <span class="n">individual</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">foo</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
                              <span class="o">^</span>
</code></pre>
</div>

<p>There are several optics predefined that allow for the zooming in of values in
the <code class="highlighter-rouge">Position</code> as well and the state of an <code class="highlighter-rouge">Entity</code>. Of course a user could define
their own optics, and it is recommended when custom state types are used,
in order to work with the <code class="highlighter-rouge">Entity</code> data.</p>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/cilib/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script src="/cilib/js/main.js"></script></body></html>